/*
 * Copyright(c) 2024 Parillume, All rights reserved worldwide
 */
package com.parillume.controller;

import com.parillume.external.chat.model.ChatTopic;
import com.parillume.model.CompanyModel;
import com.parillume.model.CorpusModel;
import com.parillume.external.chat.service.ChatGPTService;
import com.parillume.security.service.SessionService;
import com.parillume.util.StringUtil;
import java.util.List;
import org.apache.commons.lang3.tuple.MutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 *
 * @author tmargolis
 * @author tom@parillume.com
 */
@RestController
public class ChatController extends AbstractController {
    
    @Autowired
    private ChatGPTService chatService;
    
    @Autowired
    private SessionService sessionService;
    
    /**
     * Generates a chat query and returns it.
     */
    @GetMapping(path = "/automatedchatmetadata")
    public ResponseEntity<String> automatedChatMetadata(@RequestParam(value = "chatteruserid") String chatterUserId,
                                                        @RequestParam(value = "corpusversion") String corpusVersion,
                                                        @RequestParam(value = "companyid", required=false) String companyId,
                                                        @RequestParam(value = "sessionid") String sessionId)
    throws Exception {
        try {            
            sessionService.validateSession(sessionId);
            
            Pair<CompanyModel, CorpusModel> models = getModels(companyId, corpusVersion, sessionId);
            return createObjectResponse( chatService.autoGeneratedChatMetadata(chatterUserId, models.getLeft(), models.getRight()) );            
        } catch(Exception exc) {            
            return createResponse("Failed to generate automated chat", exc);
        } 
    }
    
    /**
     * Generates a chat query, submits it to ChatGPT, saves the chat metadata,
     * and returns the response from ChatGPT.
     */
    @GetMapping(path = "/automatedchat")
    public ResponseEntity<String> automatedChat(@RequestParam(value = "chatteruserid") String chatterUserId,
                                                @RequestParam(value = "corpusversion") String corpusVersion,
                                                @RequestParam(value = "companyid", required=false) String companyId,
                                                @RequestParam(value = "sessionid") String sessionId)
    throws Exception {
        try {            
            sessionService.validateSession(sessionId);
            
            Pair<CompanyModel, CorpusModel> models = getModels(companyId, corpusVersion, sessionId);
            return createResponse( chatService.autoGeneratedChat(chatterUserId, models.getLeft(), models.getRight()) );            
        } catch(Exception exc) {            
            return createResponse("Failed to generate automated chat", exc);
        } 
    }
    
    @GetMapping(path = "/structuredchat")
    public ResponseEntity<String> structuredChat(@RequestParam(value = "chattopic") ChatTopic chatTopic,
                                                 @RequestParam(value = "chatteruserid") String chatterUserId,
                                                 @RequestParam(value = "corpusversion") String corpusVersion,
                                                 @RequestParam(value = "companyid", required=false) String companyId,
                                                 @RequestParam(value = "sessionid") String sessionId)
    throws Exception {
        try {            
            sessionService.validateSession(sessionId);
            
            Pair<CompanyModel, CorpusModel> models = getModels(companyId, corpusVersion, sessionId);
            return createResponse( chatService.structuredChat(chatTopic, chatterUserId, models.getLeft(), models.getRight(), true) );            
        } catch(Exception exc) {            
            return createResponse("Failed to generate structured chat", exc);
        } 
    }
    
    @PostMapping(path = "/customchat")
    public ResponseEntity<String> customChat(@RequestBody String prompt,
                                             @RequestParam(value = "chatteruserid") String chatterUserId,
                                             @RequestParam(value = "userid") List<String> userIds,
                                             @RequestParam(value = "corpusversion") String corpusVersion,
                                             @RequestParam(value = "companyid", required=false) String companyId,
                                             @RequestParam(value = "sessionid") String sessionId)
    throws Exception {
        try {            
            sessionService.validateSession(sessionId);
            
            Pair<CompanyModel, CorpusModel> models = getModels(companyId, corpusVersion, sessionId);
            return createResponse( chatService.customChat(prompt, chatterUserId, userIds, models.getLeft(), models.getRight()) );            
        } catch(Exception exc) {            
            return createResponse("Failed to generate custom chat", exc);
        } 
    }
    
    private Pair<CompanyModel, CorpusModel> getModels(String companyId, String corpusVersion, String sessionId) 
    throws Exception {
        if(StringUtil.isEmpty(companyId))
            companyId = getCompanyId(sessionId); 

        CompanyModel company = retrieveCompany(companyId);
        if(company == null)
            throw new Exception("Company with id "+companyId+" does not exist");

        CorpusModel corpus = retrieveRequiredCorpus(corpusVersion);
        if(corpus == null)
            throw new Exception("Corpus with version " +corpusVersion+" does not exist");        
        
        return MutablePair.of(company, corpus);
    }
}
